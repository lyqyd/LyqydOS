local function verifyAcyclicTable( t, track )	
	if type(t) == "table" then
		if track[t] ~= nil then
			return false
		end
		track[t] = true
		for k,v in pairs(t) do
			if not verifyAcyclicTable(v, track) then return false end
		end
	end
	return true
end

local function trackWindow(guiTable, targetWindow)
	if not guiTable.trackedWindows[targetWindow] then
		local windowTracked = false
		if guiTable.parentWindow == targetWindow then
			guiTable.trackedWindows[targetWindow] = {}
			windowTracked = true
		else
			for k,v in ipairs(guiTable.parentProcessTable.children) do
				if v == targetWindow then
					guiTable.trackedWindows[targetWindow] = {}
					windowTracked = true
				end
			end
		end
		if not windowTracked then return false end
	end
	return true
end

local guiElement = {
	setBounds = function(self, minX, minY, maxX, maxY)
		if minX < maxX and minY < maxY then
			self.bounds.minX = minX
			self.bounds.minY = minY
			self.bounds.maxX = maxX
			self.bounds.maxY = maxY
			return true
		end
		return false
	end,
	setVisible = function(self, visible)
		self.properties.isVisible = visible == true
	end,
	setEnabled = function(self, enable)
		self.properties.isEnabled = enable == true
	end,
	coordinatesWithinBounds = function(self, x, y)
		if x >= self.minX and x <= self.maxX and y >= self.minX and y <= self.maxY then
			return true
		else
			return false
		end
	end,
}

local emetatable = {__index = guiElement}

local function newGuiElement(guiInstance, minX, minY, maxX, maxY)
	local element = {
		bounds = {
			minX = minX or 0,
			minY = minY or 0,
			maxX = maxX or 1,
			maxY = maxY or 1,
		},
		properties = {
			isVisible = true,
			isEnabled = true,
			isVolatile = false,
		},
		parentWindow = guiInstance.parentWindow,
		parentInstance = guiInstance,
	}
	setmetatable(element, emetatable)
	return element
end


local guiTable = {
	newChildWindow = function(self, w, h, x, y, caption)
		local win = window.new(w, h, x, y, caption, process.windowCompositor:newBuffer())
		self.trackedWindows[win] = true
		print(self.parentProcessID)
		process.addChildWindow(self.parentProcessID, win)
		return win
	end,

	--button gui element.  Used for clickable areas.
	button = function(self, targetWindow, minX, minY, maxX, maxY, labelTable, func, textColor, backgroundColor)
		local instance = newGuiElement(self, minX, minY, maxX, maxY)
		if targetWindow ~= nil then instance.parentWindow = targetWindow end
		instance.data = {
			label = labelTable,
			func = func,
			textColor = textColor or colors.white,
			backgroundColor = backgroundColor or colors.black,
		}
		instance.draw = function(self)
			term.redirect(self.parentWindow.redirect)
			x, y = term.getSize()
			if self.bounds.minX >= 1 and self.bounds.minY >= 1 and self.bounds.maxX <= x and self.bounds.maxY <= y then
				term.setTextColor(self.data.textColor)
				term.setBackgroundColor(self.data.backgroundColor)
				for i = self.bounds.minY, self.bounds.maxY do
					term.setCursorPos(self.bounds.minX, i)
					term.write(self.data.label[i - self.bounds.minY + 1])
				end
			end
			term.restore()
		end
		instance.eventHandler = function(self, ...)
			local event = {...}
			if self.properties.isEnabled then
				if event[1] == "mouse_click" then
					if self.data.func then
						self.data.func()
					else
						return "lgui_button_click", self.label.name, self
					end
				end
			else
				return unpack(event)
			end
		end
		instance:draw()
		table.insert(self.elements, instance)
		return instance
	end,

	--Menu gui element.  Used to generate a menu from a table.
	menu = function(self, targetWindow, minX, maxX, minY, maxY, menuTable, textColor, selectedTextColor, backgroundColor, selectedBackgroundColor)
		if not verifyAcyclicTable(menuTable, {}) then return nil, "Cannot create cyclic menu" end
		local instance = newGuiElement(self, minX, minY, maxX, maxY)
		if targetWindow ~= nil then instance.parentWindow = targetWindow end
		local instance.data = {
			textColor = textColor or colors.white,
			selectedTextColor = selectedTextColor or colors.black,
			backgroundColor = backgroundColor or colors.black,
			selectedBackgroundColor = selectedBackgroundColor or colors.white,
			drawCursor = false,
			cursor = 1,
			offset = 1,
			menuEntries = {}
			cleanTable = {}
		}
		for i, v in ipairs(menuTable) do
			if type(v) == "table" then
				local entryData = {}
				entryData.name = v.name
				entryData.state = v.state
				table.insert(instance.data.menuEntries, entryData)
				table.insert(instance.data.cleanTable, v.name)
			elseif type(v) == "string" then
				table.insert(instance.data.menuEntries, {name = v})
				table.insert(instance.data.cleanTable, v)
			end
		end

		instance.draw = function(self)
			local function getText(entryNum)
				if self.data.menuEntries[entryNum].state ~= nil then
					return (self.data.menuEntries[entryNum].state and "X " or "  ")..self.data.cleanTable[entryNum]
				else
					return self.data.cleanTable[entryNum]
				end
			end

			local function writeLine(text, length, selected)
				if selected then
					term.setTextColor(self.data.selectedTextColor)
					term.setBackgroundColor(self.data.selectedBackgroundColor)
				else
					term.setTextColor(self.data.textColor)
					term.setBackgroundColor(self.data.backgroundColor)
				end
				term.write(string.sub(text, 1, length))
			end
			term.redirect(self.parentWindow.redirect)
			--get x-length of drawable area for term.write calls.
			local xLim = maxX - minX + 1
			if maxX - minX < 2 or (maxY - minY < 2 and #self.data.cleanTable > 2) then
				return nil, "Not enough space to draw menu!"
			end
			term.clear()
			term.setCursorPos(self.bounds.minX, self.bounds.minY)
			if self.offset > 1 then
				writeLine("/\\", xLim, false)
			else
				writeLine(getText(1), xLim, self.data.drawCursor and self.data.cursor == 1)
			end
			for i=1, math.min(self.bounds.maxY - self.bounds.minY, #self.data.cleanTable + self.bounds.minY - 1) do
				term.setCursorPos(self.bounds.minX, i + self.bounds.minY - 1)
				writeLine(getText(self.offset + i), xLim, self.data.drawCursor and self.offset + i == self.cursor)
			end
			if #self.data.cleanTable >= self.bounds.maxY then
				term.setCursorPos(self.bounds.minX, self.bounds.maxY)
				if #self.data.cleanTable > self.offset + self.bounds.maxY - 1 then
					writeLine("\\/", xLim, false)
				else
					writeLine(getText(#self.data.cleanTable), xLim, self.data.drawCursor and self.offset + i == self.cursor)
				end
			end
			term.restore()
		end
		instance.eventHandler = function(self, ...)
			if event[1] == "key" then
				--up
				if event[2] == 200 then
					self.data.data.drawCursor = true
					if self.data.cursor - self.data.offset + 1 > 2 or (self.data.cursor > 1 and self.data.offset ==  1) then
						self.data.cursor = self.data.cursor - 1
						self:draw()
					elseif self.data.cursor - self.data.offset + 1 == 2 and self.data.offset > 1 then
						self.data.offset = self.data.offset - 1
						self.data.cursor = self.data.cursor - 1
						self:draw()
					end
				--down
				elseif event[2] == 208 then
					self.data.drawCursor = true
					local ylim = self.bounds.maxY - self.bounds.minY + 1
					if self.data.cursor < #self.data.cleanTable and (self.data.cursor - self.data.offset + 1 < ylim - 1 or #self.data.cleanTable <= ylim or (self.data.cursor == #self.data.cleanTable - 1 and self.data.cursor - self.data.offset + 1 == ylim - 1)) then
						self.data.cursor = self.data.cursor + 1
						self:draw()
					elseif self.data.cursor < #self.data.cleanTable and self.data.cursor - self.data.offset + 1 == ylim - 1 then
						self.data.offset = self.data.offset + 1
						self.data.cursor = self.data.cursor + 1
						self:draw()
					end
				elseif event[2] == 28 then
					if self.data.drawCursor then
						if self.data.menuEntries[self.data.cursor].state ~= nil then
							--if checked entry, toggle value
							self.data.menuEntries[self.data.cursor].state = self.data.menuEntries[self.data.cursor].state == false
							return "lgui_menu_click", self.data.cursor, self.data.menuEntries[self.data.cursor].state
						end
						return "lgui_menu_click", self.data.cursor
					end
				end
			elseif event[1] == "mouse_click" and event[2] == 1 then
				if event[4] <= #self.data.cleanTable then
					local ylim = self.bounds.maxY - self.bounds.minY + 1
					if self.data.offset > 1 and event[4] == 1 then
						--scroll up.
						self.data.offset = self.data.offset - 1
						self.data.cursor = self.data.offset + 1
						self:draw()
					elseif self.data.offset + ylim - 1 < #self.data.cleanTable and event[4] == ylim then
						--scroll down.
						self.data.offset = self.data.offset + 1
						self.data.cursor = self.data.offset + ylim - 2
						self:draw()
					else
						self.data.cursor = event[4] + self.data.offset - 1
						self.data.drawCursor = true
						self:draw()
						if self.data.menuEntries[self.data.cursor].state ~= nil then
							--if checked entry, toggle value
							self.data.menuEntries[self.data.cursor].state = self.data.menuEntries[self.data.cursor].state == false
							return "lgui_menu_click", self.data.cursor, self.data.menuEntries[self.data.cursor].state
						end
						return "lgui_menu_click", self.data.cursor
					end
				end
			end
		end
		instance:draw()
		table.insert(self.elements, instance)
		return instance
	end,

	--Generate a new window and fill it entirely with a menu, using the above menu function.
	menuWindow = function(self, x, y, menuTable, ...)
		if not verifyAcyclicTable(menuTable, {}) then return nil, "Cannot create cyclic menu" end

		--get width of menu
		menuWidth = 0
		for i, v in ipairs(menuTable) do
			if type(v) == "table" then
				menuWidth = math.max(menuWidth, string.len(v.name))
			elseif type(v) == "string" then
				menuWidth = math.max(menuWidth, string.len(v))
			end
		end

		local xLim, yLim = process.windowCompositor.x, process.windowCompositor.y
		--add one to get the borders accounted for
		if y + #elementData.menuEntries + 1 > yLim then
			y = math.max(1, yLim - #elementData.menuEntries - 1)
		end
		local width, height = math.min(x + menuWidth + 1, xLim - x - 1), math.min(yLim - 1, #elementData.menuEntries + 2)
		local xPos, yPos = targetWindow.x + x, targetWindow.y + y
		print(xPos..","..yPos..","..width..","..height)

		menuWindow = self:newChildWindow(width, height, xPos, yPos, nil)
		menuWindow:setDecorations("menu")
		local menuInstance = self:menu(menuWindow, 1, width - 1, 1, height - 1, menuTable, ...)
		menuInstance.properties.isVolatile = true
		menuInstance.cleanup = function(self)
			process.removeChildWindow(self.guiInstance.parentProcessID, self.parentWindow)
		end
		
		return menuInstance
	end,

	--Menu Bar element.  Combination of buttons and menus, generated from a table.
	menuBar = function(self, targetWindow, x, y, menuTable, ...)
		if not verifyAcyclicTable(menuTable, {}) then return nil, "Cannot create cyclic menu" end
		if not trackWindow(self, targetWindow) then return nil, "Cannot create gui in that window" end
		local elements

		local function newBarButton (x, y, name, menu, target)
			local len = string.len(name)
			local minX, maxX = x, x + len - 1
			local label = {name, name = name,}
			if menu then
				local buttonFunc = function()
					self:menuWindow(x, y + 1, menu)
				end
			end
			local instance = self:button(target, minX, y, maxX, y, label, buttonFunc)
			return instance, maxX
		end

		local xOffset = x
		local inst
		for i, v in pairs(menuTable) do
			if type(v) == "table" then
				inst, xOffset = newBarButton(xOffset, y, v.name, v.options, targetWindow)
			elseif type(v) == "string" then
				inst, xOffset = newBarButton(xOffset, y, v, nil, targetWindow)
			end
			table.insert(elements, inst)
		end
		return elements
	end,
	handleEvent = function(self, ...)
		event = {...}
		if event[1] == "mouse_click" then
			local currentFront
			if not self.parentProcessTable.children or self.parentProcessTable.children[#self.parentProcessTable.children] == "rootWindow" then
				currentFront = self.parentWindow
			else
				currentFront = self.parentProcessTable.children[#self.parentProcessTable.children]
			end
			if not self.trackedWindows[currentFront] then
				return unpack(event)
			end
			--otherwise, we are tracking this window, so see if we clicked in a gui bounding box.
			if self.trackedWindows[currentFront].guiElements then
				for k, box in ipairs(self.trackedWindows[currentFront].guiElements) do
					if event[3] >= box.bounds.minX and event[3] <= box.bounds.maxX and event[4] >= box.bounds.minY and event[4] <= box.bounds.maxY then
						--event is in this bounding box!
						return box:eventHandler(event[1], event[2], event[3] - (box.minX - 1), event[4] - (box.minY - 1))
					end
				end
				--if it's not in our bounding boxes, return the event.
				return unpack(event)
			end
		elseif event[1] == "key" or event[1] == "char" then
			--check activation keys/current state
		end
		return unpack(event)
	end,
}

local gmetatable = {
	__index = guiTable,
}

function new()
	if not (process and compositor and window and process.activeProcess) then return nil, "Incorrect environment!" end
	local g = {
		parentProcessID = process.activeProcess,
		parentProcessTable = process.processTable[process.activeProcess],
		parentWindow = process.processTable[process.activeProcess].window,
		trackedWindows = {},
		elements = {},
	}
	setmetatable( g, gmetatable )
	return g
end
