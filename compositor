local compositor = {
	newBuffer = function(self)
		local _redirect = framebuffer.new(self.x, self.y, self.target.isColor())
		local redirect = {}
		for k, v in pairs(_redirect) do
			if type(k) == "string" and type(v) == "function" then
				redirect[k] = function(...)
					local result = {_redirect[k](...)}
					if not self.deferDraw then self:draw() end
					return unpack(result)
				end
			else
				redirect[k] = _redirect[k]
			end
		end

		redirect.setBounds = function(x_min, y_min, x_max, y_max)
			redirect.buffer.minX = x_min
			redirect.buffer.maxX = x_max
			redirect.buffer.minY = y_min
			redirect.buffer.maxY = y_max
		end

		redirect.setBounds(1, 1, self.x, self.y)

		table.insert(self.bufferStack, redirect.buffer)

		return redirect
	end,
	draw = function(self, mode)
		if #self.bufferStack > 0 then
			local finalBuffer = {text = {}, textColor = {}, backColor = {}, color = self.target.isColor()}
			if mode ~= "cursor" then
				finalBuffer.sizeX, finalBuffer.sizeY = self.target.getSize()
				for i=1, self.y do
					finalBuffer.text[i] = string.rep(" ", self.x)
					finalBuffer.textColor[i] = string.rep("0", self.x)
					finalBuffer.backColor[i] = string.rep("f", self.x)
				end
				for i=1, #self.bufferStack do
					if self.bufferStack[i].minY > 0 then
						local preStop = self.bufferStack[i].minX - 1
						local preStart = math.min(1, preStop)
						local postStart = self.bufferStack[i].maxX + 1
						local postStop = self.x
						local j = self.bufferStack[i].minY
						repeat
							finalBuffer.text[j] = string.sub(string.sub(finalBuffer.text[j], preStart, preStop)..string.sub(self.bufferStack[i].text[j], self.bufferStack[i].minX, self.bufferStack[i].maxX)..string.sub(finalBuffer.text[j], postStart, postStop), 1, self.x)
							finalBuffer.textColor[j] = string.sub(string.sub(finalBuffer.textColor[j], preStart, preStop)..string.sub(self.bufferStack[i].textColor[j], self.bufferStack[i].minX, self.bufferStack[i].maxX)..string.sub(finalBuffer.textColor[j], postStart, postStop), 1, self.x)
							finalBuffer.backColor[j] = string.sub(string.sub(finalBuffer.backColor[j], preStart, preStop)..string.sub(self.bufferStack[i].backColor[j], self.bufferStack[i].minX, self.bufferStack[i].maxX)..string.sub(finalBuffer.backColor[j], postStart, postStop), 1, self.x)
							j = j + 1
						until j > self.bufferStack[i].maxY
					end
				end
			end
			finalBuffer.cursorX = self.bufferStack[#self.bufferStack].cursorX
			finalBuffer.cursorY = self.bufferStack[#self.bufferStack].cursorY
			finalBuffer.curTextColor = self.bufferStack[#self.bufferStack].curTextColor
			finalBuffer.curBackColor = self.bufferStack[#self.bufferStack].curBackColor
			--ensure cursor is inside opaque area before setting blink.
			if self.bufferStack[#self.bufferStack].cursorX >= self.bufferStack[#self.bufferStack].minX and self.bufferStack[#self.bufferStack].cursorX <= self.bufferStack[#self.bufferStack].maxX and self.bufferStack[#self.bufferStack].cursorY >= self.bufferStack[#self.bufferStack].minY and self.bufferStack[#self.bufferStack].cursorY <= self.bufferStack[#self.bufferStack].maxY then
				finalBuffer.cursorBlink = self.bufferStack[#self.bufferStack].cursorBlink
			else
				finalBuffer.cursorBlink = false
			end
			--farm out actual drawing procedures to framebuffer API.
			term.redirect(self.target)
			term.setCursorBlink(false)
			self.currentBuffer = framebuffer.draw(finalBuffer, self.currentBuffer)
			term.restore()
		end
	end,
	toFront = function(self, pos)
		table.insert(self.bufferStack, (table.remove(self.bufferStack, pos)))
		if not self.deferDraw then self:draw() end
	end,
	removeWindow = function(self, win)
		local pos = nil
		for i = 1, #self.bufferStack do
			if self.bufferStack[i] == win.target.buffer then
				pos = i
				break
			end
		end
		if pos then
			table.remove(self.bufferStack, pos)
			if not self.deferDraw then self:draw() end
		end
	end,
}

local cmetatable = {
	__index = compositor,
}

function new(target)
	local comp = {
		bufferStack = {},
		target = target or term.native,
		currentBuffer = {text = {}, textColor = {}, backColor = {}},
		deferDraw = false
	}
	setmetatable( comp, cmetatable )
	if comp.target.getSize() then
		comp.x, comp.y = comp.target.getSize()
	else
		return nil
	end
	for i=1, comp.y do
		comp.currentBuffer.text[i] = string.rep(" ", comp.x)
		comp.currentBuffer.textColor[i] = string.rep("0", comp.x)
		comp.currentBuffer.backColor[i] = string.rep("f", comp.x)
	end
	return comp
end