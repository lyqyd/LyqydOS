processTable = {}
process.focusWindow = nil
windowCompositor = compositor.new()
rawset(process, "windowCompositor", windowCompositor)
rawset(process, "processTable", processTable)

local oldTredirect = term.redirect
local oldTrestore = term.restore

local tRunHistory = {}
if fs.exists("/.runhistory") then
	local histFile=io.open("/.runhistory","r")
	tRunHistory=textutils.unserialize(histFile:read())
	histFile:close()
end

local function newTredirect(target)
	table.insert(process.redirectStack, target)
	oldTredirect(target)
end

local function newTrestore()
	table.remove(process.redirectStack)
	oldTrestore()
end

windowDimensions = {}
winDims = io.open("/.lyqwin", "r")
if winDims then
	for line in winDims:lines() do
		local dimEntry = {}
		dimEntry.x, dimEntry.y, dimEntry.w, dimEntry.h, dimEntry.max, dimEntry.path = string.match(line, "(%d+),(%d+),(%d+),(%d+),(%a+),(.*)")
		if dimEntry.x and dimEntry.path then
			table.insert(windowDimensions, dimEntry)
		end
	end
	winDims:close()
end

local function nextWindow(default)
	if processTable[process.focusWindow] and processTable[process.focusWindow].parent then
		if processTable[processTable[process.focusWindow].parent] and processTable[processTable[process.focusWindow].parent].window then
			return processTable[process.focusWindow].parent
		end
	else
		local nextBuf = windowCompositor.bufferStack[#windowCompositor.bufferStack]
		local nextActive = default
		for tNum, tInfo in ipairs(processTable) do
			if tInfo and tInfo.window then
				if tInfo.window.target.buffer == nextBuf then
					nextActive = tNum
				end
			end
		end
		return nextActive
	end
end

local function saveDimensions(proc)
	if proc.path then
		local pathFound = false
		winDims = io.open("/.lyqwin", "w")
		if winDims then
			for wNum, wInfo in ipairs(windowDimensions) do
				if wInfo.path == proc.path then
					pathFound = true
					if proc.window.maximized then
						wInfo.x = proc.window.normalSize.x
						wInfo.y = proc.window.normalSize.y
						wInfo.w = proc.window.normalSize.w
						wInfo.h = proc.window.normalSize.h
					else
						wInfo.x = proc.window.x
						wInfo.y = proc.window.y
						wInfo.w = proc.window.w
						wInfo.h = proc.window.h
					end
					wInfo.max = tostring(proc.window.maximized)
				end
				winDims:write(wInfo.x..","..wInfo.y..","..wInfo.w..","..wInfo.h..","..wInfo.max..","..wInfo.path.."\n")
			end
			if not pathFound then
				local winInfo = {}
				if proc.window.maximized then
					winInfo.x = proc.window.normalSize.x
					winInfo.y = proc.window.normalSize.y
					winInfo.w = proc.window.normalSize.w
					winInfo.h = proc.window.normalSize.h
				else
					winInfo.x = proc.window.x
					winInfo.y = proc.window.y
					winInfo.w = proc.window.w
					winInfo.h = proc.window.h
				end
				winInfo.max = tostring(proc.window.maximized)
				winInfo.path = proc.path
				table.insert(windowDimensions, winInfo)
				winDims:write(winInfo.x..","..winInfo.y..","..winInfo.w..","..winInfo.h..","..winInfo.max..","..proc.path.."\n")
			end
			winDims:close()
		end
	end
end

local function checkWindow(proc)
	if (proc and coroutine.status(proc.thread) == "dead") or (proc and proc.special and proc ~= processTable[process.focusWindow]) then
		if proc.window then
			saveDimensions(proc)
			proc.window:destroy()
		end
		return false
	end
	return true
end

local function selectWindow()
	local pList, menuList = {}, {}
	for tNum, tInfo in ipairs(process.processTable) do
		if tInfo and tInfo.window then
			table.insert(pList, tNum)
			table.insert(menuList, tInfo.window.caption)
		end
	end
	--removes self from list of running programs.
	table.remove(menuList)
	table.remove(pList)
	table.insert(menuList, "Cancel")
	local selection = menu.select(menuList)
	if pList[selection] then
		process.focusWindow = pList[selection]
		if processTable[process.focusWindow].window.minimized then processTable[process.focusWindow].window:unMinimize() end
		windowCompositor:toFront(processTable[process.focusWindow].window)
	end
end

local function startProgram()
	write("> ")
	local line = read(nil, tRunHistory)
        --don't save empty or repeated lines
	if line~="" and (#tRunHistory==0 or line~=tRunHistory[#tRunHistory]) then
		--should never be able to get above 255, but just in case, the while doesn't hurt
	        table.insert(tRunHistory,line)		
		while #tRunHistory>255 do
			table.remove(tRunHistory,256)
		end
		--update history on disk
		local histFile=io.open("/.runhistory","w")
		histFile:write(textutils.serialize(tRunHistory))
		histFile:close()
	end
	local args = {}
	for match in string.gmatch( line, "[^ \t]+" ) do
		table.insert( args, match )
	end
	path = shell.resolveProgram(table.remove(args, 1))
	if path then
		local w, h, x, y, max = 19, 9, 1, 1, "false"
		for dNum, dInfo in ipairs(windowDimensions) do
			if dInfo.path == path then
				w = dInfo.w
				h = dInfo.h
				x = dInfo.x
				y = dInfo.y
				max = dInfo.max
				break
			end
		end
		local pTable = {}
		pTable.path = path
		pTable.thread = coroutine.create(function() shell.run(path, unpack(args)) end)
		pTable.window = window.new(w, h, x, y, fs.getName(path), process.windowCompositor:newBuffer())
		if windowCompositor.target.isColor() then pTable.window:setType("standard") end
		if max == "true" then pTable.window:maximize() end
		table.insert(process.processTable, pTable)
		process.focusWindow = #process.processTable
		term.redirect(process.processTable[process.focusWindow].window.redirect)
		coroutine.resume(process.processTable[process.focusWindow].thread)
		term.restore()
	end
end

local function windowAction(actionProc)
	if processTable[actionProc] and processTable[actionProc].window then
		local selection = menu.select({"Restore", "Move", "Resize", "Minimize", "Maximize", "Close", "Cancel"})
		return selection
	end
end

local function changeWindow(manipulationWindow, action)
	if action == 1 then
		if processTable[manipulationWindow].window.maximized then
			processTable[manipulationWindow].window:restore()
			os.queueEvent("window_resize")
		end
	elseif action == 2 then
		--move
		while true do
			e, p1, p2, p3 = os.pullEvent()
			if e == "key" then
				if p1 == 200 then
					--up
					processTable[manipulationWindow].window:move(processTable[manipulationWindow].window.x, processTable[manipulationWindow].window.y - 1)
				elseif p1 == 203 then
					--left
					processTable[manipulationWindow].window:move(processTable[manipulationWindow].window.x - 1, processTable[manipulationWindow].window.y)
				elseif p1 == 205 then
					--right
					processTable[manipulationWindow].window:move(processTable[manipulationWindow].window.x + 1, processTable[manipulationWindow].window.y)
				elseif p1 == 208 then
					--down
					processTable[manipulationWindow].window:move(processTable[manipulationWindow].window.x, processTable[manipulationWindow].window.y + 1)
				elseif p1 == 28 then
					--enter
					break
				end
			elseif e == "mouse_click" and p1 == 1 then
				--mouse click
				processTable[manipulationWindow].window:move(p2, p3)
				break
			end
		end
	elseif action == 3 then
		--resize
		local newX, newY = processTable[manipulationWindow].window.x + processTable[manipulationWindow].window.w - 1, processTable[manipulationWindow].window.y + processTable[manipulationWindow].window.h - 1
		term.setCursorPos(newX, newY)
		term.write("*")
		term.setCursorPos(newX, newY)
		term.setCursorBlink(true)
		local xlim, ylim = windowCompositor.target.getSize()
		while true do
			e, p1, p2, p3 = os.pullEvent()
			term.setCursorBlink(false)
			if e == "key" then
				if p1 == 200 then
					--up
					if newY > processTable[manipulationWindow].window.y + 2 then
						windowCompositor.currentBuffer.text[newY] = string.sub(windowCompositor.currentBuffer.text[newY], 1, newX - 1).."*"..string.sub(windowCompositor.currentBuffer.text[newY], newX + 1)
						newY = newY - 1
					end
				elseif p1 == 203 then
					--left
					if newX > processTable[manipulationWindow].window.x + 4 then
						windowCompositor.currentBuffer.text[newY] = string.sub(windowCompositor.currentBuffer.text[newY], 1, newX - 1).."*"..string.sub(windowCompositor.currentBuffer.text[newY], newX + 1)
						newX = newX - 1
					end
				elseif p1 == 205 then
					--right
					if newX < xlim then
						windowCompositor.currentBuffer.text[newY] = string.sub(windowCompositor.currentBuffer.text[newY], 1, newX - 1).."*"..string.sub(windowCompositor.currentBuffer.text[newY], newX + 1)
						newX = newX + 1
					end
				elseif p1 == 208 then
					--down
					if newY < ylim then
						windowCompositor.currentBuffer.text[newY] = string.sub(windowCompositor.currentBuffer.text[newY], 1, newX - 1).."*"..string.sub(windowCompositor.currentBuffer.text[newY], newX + 1)
						newY = newY + 1
					end
				elseif p1 == 28 then
					--enter
					break
				end
				windowCompositor:draw()
				term.setCursorPos(newX, newY)
				term.write("*")
				term.setCursorPos(newX, newY)
				term.setCursorBlink(true)
			elseif e == "mouse_click" and p1 == 1 then
				if p2 > processTable[manipulationWindow].window.x + 4 and p3 > processTable[manipulationWindow].window.y + 2 then
					newX, newY = p2, p3
					break
				end
			end
		end
		processTable[manipulationWindow].window:resize(newX - processTable[manipulationWindow].window.x + 1, newY - processTable[manipulationWindow].window.y + 1)
		processTable[manipulationWindow].window.maximized = false
		os.queueEvent("window_resize")
	elseif action == 4 then
		processTable[manipulationWindow].window:minimize()
	elseif action == 5 then
		if not processTable[manipulationWindow].window.maximized then
			processTable[manipulationWindow].window:maximize()
			os.queueEvent("window_resize")
		end
	elseif action == 6 then
		saveDimensions(processTable[manipulationWindow])
		processTable[manipulationWindow].window:destroy()
		processTable[manipulationWindow] = false
		process.focusWindow = nextWindow(1)
		if processTable[process.focusWindow] then
			windowCompositor:toFront(processTable[process.focusWindow].window)
		end
	end
end

local function checkProcess(proc, passback)
	if not checkWindow(processTable[proc]) then
		if processTable[proc].special then
			if processTable[proc].special == "window_action" then
				changeWindow(processTable[proc].parent, passback[2])
			end
		end
		if proc == process.focusWindow then
			process.focusWindow = nextWindow(1)
			if processTable[process.focusWindow] then
				windowCompositor:toFront(processTable[process.focusWindow].window)
			end
		end
	end
end

local function windowOptionsMenu()
	if processTable[process.focusWindow] and not processTable[process.focusWindow].special then
		local pTable = {}
		local parent = process.focusWindow
		pTable.thread = coroutine.create(windowAction)
		pTable.window = window.new(15, 9, processTable[parent].window.x, processTable[parent].window.y, "Action Menu", windowCompositor:newBuffer())
		pTable.window:setDecorations("menu")
		table.insert(processTable, pTable)
		process.focusWindow = #processTable
		term.redirect(processTable[process.focusWindow].window.redirect)
		passback = {coroutine.resume(processTable[process.focusWindow].thread, parent)}
		term.restore()
		processTable[process.focusWindow].special = "window_action"
	end
end

local function chooseWindowMenu()
	if processTable[process.focusWindow] then
		local pTable = {}
		pTable.thread = coroutine.create(selectWindow)
		pTable.window = window.new(19, 11, 1, 1, "Select Window", windowCompositor:newBuffer())
		table.insert(processTable, pTable)
		process.focusWindow = #process.processTable
		term.redirect(processTable[process.focusWindow].window.redirect)
		coroutine.resume(processTable[process.focusWindow].thread)
		term.restore()
		processTable[process.focusWindow].special = "select_window"
	end
end

local function runProgramDialog()
	local pTable = {}
	pTable.thread = coroutine.create(startProgram)
	pTable.window = window.new(30, 3, 2, 2, "Run Program", windowCompositor:newBuffer())
	table.insert(processTable, pTable)
	process.focusWindow = #process.processTable
	term.redirect(processTable[process.focusWindow].window.redirect)
	coroutine.resume(processTable[process.focusWindow].thread)
	term.restore()
	processTable[process.focusWindow].special = "run_program"
end

local function resumeProcess(pID, eventTable)
	local redir = false
	if processTable[pID].window then
		term.redirect(processTable[pID].window.redirect)
		redir = true
		if processTable[pID].redirectStack then
			for _,t in ipairs(processTable[pID].redirectStack) do
				term.redirect(t)
			end
		end
		rawset(term, "redirect", newTredirect)
		rawset(term, "restore", newTrestore)
	end
	process.activeProcess = pID
	passback = {coroutine.resume(processTable[pID].thread, unpack(eventTable))}
	process.activeProcess = nil
	if redir then
		rawset(term, "redirect", oldTredirect)
		rawset(term, "restore", oldTrestore)
		processTable[pID].redirectStack = {}
		for i=1, #process.redirectStack do
			term.restore()
			processTable[pID].redirectStack[i] = process.redirectStack[i]
		end
		term.restore()
	end
	checkProcess(pID, passback)
end

term.clear()
local titlebar = windowCompositor:newBuffer()
local titlebarWidth, titlebarHeight = titlebar.getSize()
titlebar.buffer.text[1] = "=LyqydOS"..string.rep("=", titlebarWidth - 8)
windowCompositor:draw()

local watchMouseDragging = false
local mouseStartX = nil
local mouseStartY = nil
local mouseDragAction = nil

while true do
	local titlebarItems = {}
	for i=1, #processTable do
		if not checkWindow(processTable[i]) then
			processTable[i] = false
		else
			if processTable[i] and processTable[i].window and not processTable[i].special then
				local tBarEntry = {pID = i, text = processTable[i].window.caption}
				table.insert(titlebarItems, tBarEntry)
			end
		end
	end
	local taskText = ""
	local tasksClickable = 0
	local usableWidth = titlebarWidth - 10
	for eNum, eInfo in ipairs(titlebarItems) do
		if #taskText + 9 > usableWidth then
			if #taskText > 9 then
				taskText = string.sub(taskText, 1, -10).."More... |"
			end
			break
		end
		local str = string.sub(eInfo.text, 1, 8)
		str = str..string.rep(" ", 8 - #str)
		if taskText == "" then taskText = "|" end
		taskText = taskText..str.."|"
		tasksClickable = tasksClickable + 1
	end
	titlebar.buffer.text[1] = "=LyqydOS="..taskText..string.rep("=", titlebarWidth - (#taskText + 9))
	windowCompositor:draw()
	event = {coroutine.yield()}
	if event[1] == "key" and event[2] == 59 then
		--run menu for keyboard users.
		runProgramDialog()
	elseif event[1] == "key" and event[2] == 61 then
		--window switching menu
		chooseWindowMenu()
	elseif event[1] == "key" and event[2] == 62 then
		--window controls menu
		windowOptionsMenu()
	elseif event[1] == "mouse_click" then
		watchMouseDragging = false
		local windowFound = false
		for i = #windowCompositor.bufferStack, 1, -1 do
			for pNum, pInfo in pairs(processTable) do
				if pInfo and pInfo.window and pInfo.window.target.buffer and pInfo.window.target.buffer == windowCompositor.bufferStack[i] then
					--correct window in order, break even if we don't get the click here.
					if event[3] >= pInfo.window.x and event[3] <= pInfo.window.x + pInfo.window.w - 1 and event[4] >= pInfo.window.y and event[4] <= pInfo.window.y + pInfo.window.h - 1 and not pInfo.window.minimized then
						windowFound = true
						if process.focusWindow ~= pNum then
							process.focusWindow = pNum
							windowCompositor:toFront(processTable[process.focusWindow].window)
						end
						event[3] = event[3] - pInfo.window.x
						event[4] = event[4] - pInfo.window.y
						if event[3] > 0 and event[3] < pInfo.window.w - 1 and event[4] > 0 and event[4] < pInfo.window.h - 1 then
							resumeProcess(process.focusWindow, event)
						elseif event[4] == 0 and event[2] == 2 then
							--right click on window title bar, open window menu.
							windowOptionsMenu()
						elseif (pInfo.window.windowType == "modal" and event[4] == 0 and event[2] == 1 and pInfo.window.w - event[3] == 3) or (pInfo.window.windowType == "standard" and event[4] == 0 and event[2] == 1 and pInfo.window.w - event[3] > 2 and pInfo.window.w - event[3] < 6) then
							local action = pInfo.window.w - event[3] - 2
							if action == 1 then
								--close window
								saveDimensions(processTable[process.focusWindow])
								processTable[process.focusWindow].window:destroy()
								processTable[process.focusWindow] = false
								process.focusWindow = nextWindow(1)
								if processTable[process.focusWindow] then
									windowCompositor:toFront(processTable[process.focusWindow].window)
								end
							elseif action == 2 then
								if pInfo.window.maximized then
									pInfo.window:restore()
									os.queueEvent("window_resize")
								else
									pInfo.window:maximize()
									os.queueEvent("window_resize")
								end
							elseif action == 3 then
								pInfo.window:minimize()
							end
						elseif event[4] == 0 and event[2] == 1 then
							--clicked on titlebar, set variables to see if we drag.
							watchMouseDragging = true
							mouseDragAction = "move"
							mouseStartX = event[3] + pInfo.window.x
							mouseStartY = event[4] + pInfo.window.y
						elseif event[3] == pInfo.window.w - 1 and event[4] == pInfo.window.h - 1 and event[2] == 1 then
							--clicked on lower right corner, resize.
							watchMouseDragging = true
							mouseDragAction = "resize"
							mouseStartX = event[3] + pInfo.window.x
							mouseStartY = event[4] + pInfo.window.y
						end
					end
					break
				end
			end
			if windowFound then break end
		end
		if not windowFound and event[4] == 1 then
			--click on titlebar with no window covering it.
			if event[3] > 1 and event[3] < 9 and event[2] == 1 then
				--clicked on the LyqydOS button
				runProgramDialog()
			elseif event[3] > 9 then
				--clicked on task bar.
				clickItem = math.floor((event[3] - 1) / 9)
				if (event[3] - 10 ) % 9 ~= 0 and clickItem <= tasksClickable then
					--they clicked on the name itself, not the boundary line.
					if clickItem == tasksClickable and clickItem < #titlebarItems then
						--display the window choice dialog
						chooseWindowMenu()
					else
						if process.focusWindow ~= titlebarItems[clickItem].pID then
							process.focusWindow = titlebarItems[clickItem].pID
						end
						windowCompositor:toFront(processTable[process.focusWindow].window)
						if processTable[process.focusWindow].window.minimized then processTable[process.focusWindow].window:unMinimize() end
						if event[2] == 2 then
							--they right-clicked, so let's also display the window action menu.
							windowOptionsMenu()
						end
					end
				end
			end
		end
	elseif event[1] == "mouse_drag" then
		--mouse is dragging, see if we need to do something with windows.
		if watchMouseDragging then
			if mouseDragAction == "move" then
				processTable[process.focusWindow].window:move(processTable[process.focusWindow].window.x + (event[3] - mouseStartX), processTable[process.focusWindow].window.y + (event[4] - mouseStartY))
				mouseStartX = event[3]
				mouseStartY = event[4]
			elseif mouseDragAction == "resize" then
				processTable[process.focusWindow].window:resize(processTable[process.focusWindow].window.w + (event[3] - mouseStartX), processTable[process.focusWindow].window.h + (event[4] - mouseStartY))
				mouseStartX = event[3]
				mouseStartY = event[4]
				processTable[process.focusWindow].window.maximized = false
				os.queueEvent("window_resize")
			end
		elseif processTable[process.focusWindow] and processTable[process.focusWindow].window then
			event[3] = event[3] - processTable[process.focusWindow].window.x
			event[4] = event[4] - processTable[process.focusWindow].window.y
			if event[3] > 0 and event[3] < processTable[process.focusWindow].window.w - 1 and event[4] > 0 and event[4] < processTable[process.focusWindow].window.h - 1 then
				resumeProcess(process.focusWindow, event)
			end
		end
	elseif event[1] == "mouse_scroll" then
		if processTable[process.focusWindow] and processTable[process.focusWindow].window then
			event[3] = event[3] - processTable[process.focusWindow].window.x
			event[4] = event[4] - processTable[process.focusWindow].window.y
			if event[3] > 0 and event[3] < processTable[process.focusWindow].window.w - 1 and event[4] > 0 and event[4] < processTable[process.focusWindow].window.h - 1 then
				resumeProcess(process.focusWindow, event)
			end
		end
	else
		if processTable[process.focusWindow] then
			resumeProcess(process.focusWindow, event)
		end
		--handle background processes.
		if event[1] ~= "key" and event[1] ~= "char" and event[1] ~= "mouse_click" and event[1] ~= "mouse_drag" and event[1] ~= "mouse_scroll" and event ~= "window_resize" then
			for tNum, tInfo in ipairs(processTable) do
				if tNum ~= process.focusWindow and tInfo and tInfo.listening then
					for k, eType in ipairs(tInfo.listening) do
						if event[1] == eType then
							resumeProcess(tNum, event)
							break
						end
					end
				end
			end
		end
	end
end